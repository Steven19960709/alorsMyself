# 结构型模式

结构型模式涉及到如何组合类和对象之间的关系以获取更大的结构。

结构型模式采用继承机制来实现接口或实现。

结构型对象模式不是对接口和实现进行组合，而是描述了，如何对一些对象进行组合，从而实现新功能和一些方法。

因为可以在运行时更改对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制使用静态类组合是不可能实现的。

Adapter模式，Composite模式，Flyweight模式，Bridge模式，Decorator模式。

Adapter：使得一个借口与其他借口兼容，从而给出多个不同借口的同一抽象。

Composite：结构型对象模式的一个实例。他描述了如何构造一个类层次结构，这一结构由两种类型的对象所对应的类构成。

Proxy模式中，proxy对象作为其他对象的一个方便的替代或占位符。Proxy模式还提供了对对象的一些特有性质的一些程度的间接访问，从而可以限制，增强或修改这些性质。

Flyweight模式：为了共享对象定义了一个结构。至少有两个原因要求对象的共享：效率和一致性。Flyweight的对象共享机制主要强调的是空间效率。使用对象共享而不是进行对象复制，可以节省大量的空间资源。但是仅当这些对象没有定义与上下文才可以被共享。

Facade模式则描述了如何用单个对象表示正各子系统。facade的职责就是将消息转发给他所表示的对象。

Bridge模式是将对象的抽象和其实现分离，从而独立地改变因他们。

Decorator模式描述了如何动态地为对象添加职责。Decorator模式是一个结构型模式。

## Adapter（适配器）模式——类对象结构型模式

意图：将一个类的接口转换成客户希望的另外一个接口。是的原本由于接口不兼容而不能一起工作的哪些类可以一起工作。

别名：包装类，Wrapper

不应该仅仅为了实现一个应用，底层库采用特定的接口。

可以使用一个适配器来进行接口的适配。

适用性：

- 想要使用一个已经存在的类，而它的接口不符合需求
- 想创建一个可以复用的类，该类可以与其他不相干的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作
- （仅适用于对象的Adapter）你想使用一些已经存在的子类，但是不可能对每一个都畸形子类化来匹配它们的接口。

参与者：

- target：定义client使用的与特定领域相关的接口。
- Client（Drawing Editor）与复核Target接口的对象协同
- Adapter对Adaptee的接口与Target接口进行适配。

考虑因素：

- Adapter匹配程度：对Adaptee的接口与Target的接口匹配的工作量。
- 可插入的Adapter，当其他的类使用一个类时，如果所需的假定条件越少，这个类的可复用性越好

## Bridge(桥接) 对象结构型模式

意图：将抽象部分与它的实现部分分离，使他们都可以独立变化

别名：Handle、Body

动机：当一个抽象可能有多个实现时，通常是继承来协调它们。抽象类定义对该抽象的接口，而且具体的子类则用不同方式加以实现。

继承的问题：

- 需要为每一个实例类型都创建一个子类。
- 是的客户代码与平台相关

Bridge模式解决以上问题是，将window抽象和它的实现部分分别放在独立的类层次结构中。

适用性：

- 你不希望在抽象和它的实现部分之间有一个固定的绑定关系
- 类的抽象以及它的实现部分应可以被选择或者切换
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必要重新编译。

参与者：

- Abstraction：定义抽象类的接口
- RefinedAbstraction：扩充有Abstraction定义的接口
- Implementor：定义实现类的接口，提供基本操作，Abstraction定义的事基于这些基本操作的较高层次的操作。
- ConcreteImplementor：实现Implementor接口并定义它的具体实现。

优点：

- 分离接口及其实现部分 一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。
- 提高可扩充性 你可以独立地Abstraction和Implementor层次结构进行扩充。
- 实现细节对客户透明

## 组合模式 Composite —— 对象结构型模式

意图；将对象组合成树型结构来表示“部分——整体”的层次结构。

动机：Composite模式的关键是一个抽象类，它既可以表示图元，也可以表示图元的容器。